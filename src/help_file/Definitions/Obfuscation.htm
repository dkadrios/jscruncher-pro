<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">

<html>

<!--(==============================================================)-->
<!--(Document created with RoboEditor. )============================-->
<!--(==============================================================)-->

<head>

<title>Obfuscation</title>

<!--(Meta)==========================================================-->

<meta http-equiv=content-type content="text/html; charset=windows-1252">
<meta name=generator content="RoboHELP by eHelp Corporation - www.ehelp.com">
<meta name=generator-major-version content=0.1>
<meta name=generator-minor-version content=1>
<meta name=filetype content=kadov>
<meta name=filetype-version content=1>
<meta name=page-count content=1>
<meta name=layout-height content=806>
<meta name=layout-width content=614>


<!--(Links)=========================================================-->

<link rel="StyleSheet" href="..\default.css">



</head>

<!--(Body)==========================================================-->


<body>

<h1>Obfuscation</h1>

<p><span style="font-weight: bold; font-size: 8pt;">Note</span><span style="font-size: 10pt;">: 
 <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->Obfuscation 
 is disabled by default. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->To 
 enable it, click on View-&gt;Compression Settings and check the box located 
 on the Obfuscation tab.</span></p>

<p>&nbsp;</p>

<p>JSCruncher Pro uses a mapping strategy for producing code obfuscation. 
 <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->All the 
 files you have selected to compress are first tokenized and compared to 
 a set of <a href="Map_Files.htm">map files</a>. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->Any 
 tokens for which there is already a map entry are replaced with that entry. 
 <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->If a token 
 is new, a random map key is created and added to an internal map file 
 (aka. the 'session map').</p>

<p>&nbsp;</p>

<p>The map files work simultaneously across all selected files, so obfuscated 
 references remain intact.</p>

<p>&nbsp;</p>

<p>Here is a before and after example of typical obfuscation:</p>

<p>&nbsp;</p>

<p class=Code>function autocompleteKey(E){</p>

<p class=Code><!--kadov_tag{{<spaces>}}-->&nbsp;&nbsp;<!--kadov_tag{{</spaces>}}-->var 
 e = core.findTarget(E,&quot;INPUT&quot;);</p>

<p class=Code><!--kadov_tag{{<spaces>}}-->&nbsp;&nbsp;<!--kadov_tag{{</spaces>}}-->var 
 k = core.isIE?E.keyCode:E.which;//E.charCode;</p>

<p class=Code><!--kadov_tag{{<spaces>}}-->&nbsp;&nbsp;<!--kadov_tag{{</spaces>}}-->if(core._isSpecialKey(k))return 
 true; // take no action, let the keystroke surface</p>

<p class=Code><!--kadov_tag{{<spaces>}}-->&nbsp;&nbsp;<!--kadov_tag{{</spaces>}}-->core.inputReplaceSelection(e, 
 String.fromCharCode(k));</p>

<p class=Code><!--kadov_tag{{<spaces>}}-->&nbsp;&nbsp;<!--kadov_tag{{</spaces>}}-->var 
 len = e.value.length;</p>

<p class=Code><!--kadov_tag{{<spaces>}}-->&nbsp;&nbsp;<!--kadov_tag{{</spaces>}}-->var 
 m <!--kadov_tag{{<spaces>}}-->&nbsp;&nbsp;<!--kadov_tag{{</spaces>}}-->= 
 core._autocompleteMatch(e.value, e._autocompleteList, e.casesensitive);</p>

<p class=Code><!--kadov_tag{{<spaces>}}-->&nbsp;&nbsp;<!--kadov_tag{{</spaces>}}-->if(m&gt;=0){</p>

<p class=Code><!--kadov_tag{{<spaces>}}-->&nbsp;&nbsp;&nbsp;&nbsp;<!--kadov_tag{{</spaces>}}-->e.value 
 = e._autocompleteList[m];</p>

<p class=Code><!--kadov_tag{{<spaces>}}-->&nbsp;&nbsp;&nbsp;&nbsp;<!--kadov_tag{{</spaces>}}-->core.inputSelectRange(e, 
 len, e.value.length);</p>

<p class=Code><!--kadov_tag{{<spaces>}}-->&nbsp;&nbsp;&nbsp;&nbsp;<!--kadov_tag{{</spaces>}}-->if(e.onautocomplete)e.onautocomplete(m); 
 // returns index in list</p>

<p class=Code><!--kadov_tag{{<spaces>}}-->&nbsp;&nbsp;<!--kadov_tag{{</spaces>}}-->}</p>

<p class=Code><!--kadov_tag{{<spaces>}}-->&nbsp;&nbsp;<!--kadov_tag{{</spaces>}}-->if(E 
 &amp;&amp; E.preventDefault)E.preventDefault(); // for moz</p>

<p class=Code><!--kadov_tag{{<spaces>}}-->&nbsp;&nbsp;<!--kadov_tag{{</spaces>}}-->return 
 false; // for non moz</p>

<p class=Code>};</p>

<p><!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}--></p>

<p>Compressing with obfuscation will yield something like:</p>

<p>&nbsp;</p>

<p class=Code>function autocompleteKey(E){var r1a=l6q.TO4(E,&quot;INPUT&quot;);var 
 k03=l6q.vN6?E.C7Q:E.x3l;if(l6q.Br5(k03))return true;l6q.d8C(r1a,String.fromCharCode(k03));var 
 K74=r1a.value.length;var w2J=l6q.KYr(r1a.value,r1a.guW,r1a.KFx);if(w2J&gt;=0){r1a.value=r1a.guW[w2J];l6q.Kk1(r1a,K74,r1a.value.length);if(r1a.x4Y)r1a.x4Y(w2J)}if(E&amp;&amp;E.preventDefault)E.preventDefault();return 
 false};</p>

<p class=Code>&nbsp;</p>

<p>As you can see, obfuscation can make your code very time-consuming to 
 decipher and reverse engineer, even on such a small scale. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->When 
 used with larger projects, decoding it becomes a fruitless effort.</p>

<p>&nbsp;</p>

<p>The tokens that JSCruncher uses to replace your variable and function 
 names <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->are 
 completely random and <span style="font-weight: bold;">different every 
 time you run the compression</span>. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->This 
 hinders the use of any automated tools to decipher the code.</p>

</body>

</html>
